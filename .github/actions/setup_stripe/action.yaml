name: 'Setup Stripe'
description: 'Creates Stripe products, prices, and webhooks for payments'

inputs:
  stripe_secret_key:
    description: 'Stripe secret key'
    required: true
  cloudflare_account_id:
    description: 'Cloudflare Account ID'
    required: true
  cloudflare_api_token:
    description: 'Cloudflare API token'
    required: true
  GH_PERSONAL_ACCESS_TOKEN:
    description: 'GitHub Personal Access Token'
    required: true
    
runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install Stripe
      shell: bash
      run: 'npm install stripe'

    - name: Setup GitHub Secret
      shell: bash
      run: |
        # Get GitHub's public key for encrypting secrets
        echo "üîë Getting GitHub public key..."
        PUBLIC_KEY_RESPONSE=$(curl -s \
          -H "Authorization: Bearer ${{ inputs.GH_PERSONAL_ACCESS_TOKEN }}" \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/repos/${{ github.repository }}/actions/secrets/public-key")
        
        PUBLIC_KEY=$(echo "$PUBLIC_KEY_RESPONSE" | jq -r '.key')
        KEY_ID=$(echo "$PUBLIC_KEY_RESPONSE" | jq -r '.key_id')
        
        if [ "$PUBLIC_KEY" = "null" ] || [ -z "$PUBLIC_KEY" ]; then
          echo "‚ùå Failed to get GitHub public key"
          echo "$PUBLIC_KEY_RESPONSE"
          exit 1
        fi
        
        echo "‚úÖ Got GitHub public key (ID: $KEY_ID)"
        
        # The webhook secret will be set by the Node.js script
        # We'll encrypt it there and store it as a GitHub secret

    - name: Get domains from R2
      id: get-domains
      shell: bash
      run: |
        echo "Retrieving domains from R2..."
        
        # Get domain mappings from R2
        MAPPINGS_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/${{ inputs.cloudflare_account_id }}/r2/buckets/domain-mappings/objects/mappings.json" \
          -H "Authorization: Bearer ${{ inputs.cloudflare_api_token }}" \
          -H "Content-Type: application/json")
        
        echo "Raw response from R2:"
        echo "$MAPPINGS_RESPONSE"
        
        # Check if we got a valid response
        if ! echo "$MAPPINGS_RESPONSE" | jq empty 2>/dev/null; then
          echo "::error::Failed to retrieve domain mappings from R2 - invalid JSON"
          echo "$MAPPINGS_RESPONSE"
          exit 1
        fi
        
        # Check if response is an array (success case) or has errors
        if echo "$MAPPINGS_RESPONSE" | jq -e 'type == "array"' > /dev/null; then
          # Response is an array, which is what we expect
          echo "‚úÖ Successfully retrieved domain mappings from R2"
        elif echo "$MAPPINGS_RESPONSE" | jq -e '.errors' > /dev/null; then
          # Response has errors
          echo "::error::Failed to get domain mappings"
          echo "$MAPPINGS_RESPONSE" | jq -r '.errors[0].message'
          exit 1
        else
          echo "::error::Unexpected response format from R2"
          echo "$MAPPINGS_RESPONSE"
          exit 1
        fi
        
        # Store the domains as a single line JSON string
        echo "domains=$(echo "$MAPPINGS_RESPONSE" | jq -c '.')" >> $GITHUB_OUTPUT
        echo "Retrieved $(echo "$MAPPINGS_RESPONSE" | jq '. | length') domains from R2"
        
        # Also write to a temporary file for the Node.js script
        echo "$MAPPINGS_RESPONSE" > /tmp/domains.json
        echo "Wrote domains to /tmp/domains.json"

    - name: Setup Stripe Products and Webhooks
      shell: bash
      run: |
        node -e "
        const Stripe = require('stripe');
        const fs = require('fs');
        const stripe = new Stripe('${{ inputs.stripe_secret_key }}', {
          apiVersion: '2023-10-16'
        });
        
        async function setupStripe() {
          try {
            console.log('üîß Setting up Stripe products, prices, and webhooks for all domains...');
            
            // Read domains from the temporary file
            const domainsData = fs.readFileSync('/tmp/domains.json', 'utf8');
            const domainList = JSON.parse(domainsData);
            
            console.log('üìã Processing', domainList.length, 'domains...');
            
            const results = [];
            
            // Process each domain
            for (const domainObj of domainList) {
              const domain = domainObj.domain;
              console.log('\\nüåê Processing domain:', domain);
              
              // 1. Get or create domain-specific product
              const productName = 'Premium Plan - ' + domain;
              console.log('üì¶ Checking domain-specific product:', productName);
              let products = await stripe.products.list({ limit: 100, active: true });
              let product = products.data.find(p => p.name === productName);
              
              // Generate a business name based on the domain
              const businessName = domain.replace(/^www\./, '').split('.')[0];
              const displayBusinessName = businessName.charAt(0).toUpperCase() + businessName.slice(1);
              
              if (!product) {
                product = await stripe.products.create({
                  name: productName,
                  description: 'Premium subscription with enhanced features for ' + domain,
                  active: true,
                  metadata: {
                    domain: domain,
                    business_name: displayBusinessName,
                    statement_descriptor: displayBusinessName
                  }
                });
                console.log('‚úÖ Created domain-specific product:', product.id, 'with business name:', displayBusinessName);
              } else {
                console.log('‚úÖ Using existing domain-specific product:', product.id, 'with business name:', displayBusinessName);
              }
              
              // 2. Get or create domain-specific price
              console.log('üí∞ Checking domain-specific price...');
              let prices = await stripe.prices.list({ 
                product: product.id, 
                active: true,
                type: 'recurring'
              });
              let price = prices.data.find(p => p.currency === 'gbp' && p.recurring?.interval === 'month');
              
              if (!price) {
                price = await stripe.prices.create({
                  product: product.id,
                  unit_amount: 1299, // ¬£12.99 in pence
                  currency: 'gbp',
                  recurring: { interval: 'month' },
                  active: true,
                  metadata: {
                    domain: domain,
                    business_name: displayBusinessName
                  }
                });
                console.log('‚úÖ Created domain-specific price:', price.id, 'with business name:', displayBusinessName);
              } else {
                console.log('‚úÖ Using existing domain-specific price:', price.id, 'with business name:', displayBusinessName);
              }
              
              // Store results for this domain
              results.push({
                domain: domain,
                product_id: product.id,
                price_id: price.id
              });
              
              console.log('‚úÖ Completed setup for', domain);
            }
            
            // 3. Setup webhook for auth service
            console.log('\\nüîó Setting up Stripe webhook for auth service...');
            
            // Get auth service domain from the first domain (assuming auth service is on the same infrastructure)
            const authServiceDomain = domainList[0]?.domain || 'auth.example.com';
            const webhookUrl = 'https://' + authServiceDomain + '/auth/webhook';
            
            console.log('üì° Webhook URL:', webhookUrl);
            
            // Check if webhook already exists
            const existingWebhooks = await stripe.webhookEndpoints.list({ limit: 100 });
            let webhook = existingWebhooks.data.find(w => w.url === webhookUrl);
            
            const requiredEvents = [
              'checkout.session.completed',
              'customer.subscription.created',
              'customer.subscription.updated',
              'customer.subscription.deleted',
              'invoice.payment_succeeded',
              'invoice.payment_failed'
            ];
            
            if (webhook) {
              console.log('‚úÖ Using existing webhook:', webhook.id);
              
              // Check if webhook has all required events
              const currentEvents = webhook.enabled_events;
              const missingEvents = requiredEvents.filter(event => !currentEvents.includes(event));
              
              if (missingEvents.length > 0) {
                console.log('‚ö†Ô∏è Webhook missing events:', missingEvents);
                console.log('üìù Updating webhook with missing events...');
                
                webhook = await stripe.webhookEndpoints.update(webhook.id, {
                  enabled_events: requiredEvents
                });
                console.log('‚úÖ Updated webhook with all required events');
              } else {
                console.log('‚úÖ Webhook already has all required events');
              }
            } else {
              console.log('üìù Creating new webhook...');
              webhook = await stripe.webhookEndpoints.create({
                url: webhookUrl,
                enabled_events: requiredEvents,
                description: 'Auth Service Webhook'
              });
              console.log('‚úÖ Created new webhook:', webhook.id);
            }
            
            // 4. Output configuration summary
            console.log('\\nüìã Stripe Configuration Summary:');
            results.forEach(result => {
              console.log(result.domain + ': Product ' + result.product_id + ', Price ' + result.price_id);
            });
            console.log('Webhook: ' + webhook.id + ' (Secret: [REDACTED])');
            
            // 5. Set outputs
            if (results.length > 0) {
              console.log('product_id=' + results[0].product_id + ' >> $GITHUB_OUTPUT');
              console.log('price_id=' + results[0].price_id + ' >> $GITHUB_OUTPUT');
              console.log('all_results=' + JSON.stringify(results) + ' >> $GITHUB_OUTPUT');
            }
            
            // Always output webhook info regardless of results
            console.log('webhook_id=' + webhook.id + ' >> $GITHUB_OUTPUT');
            console.log('webhook_secret=' + webhook.secret + ' >> $GITHUB_OUTPUT');
            
            // Log webhook info without exposing the secret
            console.log('‚úÖ Webhook configured: ' + webhook.id + ' (Secret: [REDACTED])');
            
            // Store webhook secret as GitHub repository secret
            console.log('üîê Storing webhook secret as GitHub repository secret...');
            
            // Get GitHub public key (already retrieved in previous step)
            const { execSync } = require('child_process');
            const publicKeyResponse = execSync('curl -s -H "Authorization: Bearer ${{ inputs.GH_PERSONAL_ACCESS_TOKEN }}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/${{ github.repository }}/actions/secrets/public-key"', { encoding: 'utf8' });
            const publicKeyData = JSON.parse(publicKeyResponse);
            
            if (!publicKeyData.key) {
              console.error('‚ùå Failed to get GitHub public key');
              process.exit(1);
            }
            
            // Encrypt the webhook secret
            const crypto = require('crypto');
            const encryptedSecret = crypto.publicEncrypt(
              {
                key: publicKeyData.key,
                padding: crypto.constants.RSA_PKCS1_PADDING
              },
              Buffer.from(webhook.secret)
            ).toString('base64');
            
            // Store the encrypted secret
            const secretPayload = JSON.stringify({
              encrypted_value: encryptedSecret,
              key_id: publicKeyData.key_id
            });
            
            const secretResponse = execSync('curl -X PUT -H "Authorization: Bearer ${{ inputs.GH_PERSONAL_ACCESS_TOKEN }}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" -H "Content-Type: application/json" "https://api.github.com/repos/${{ github.repository }}/actions/secrets/STRIPE_WEBHOOK_SECRET" -d \'' + secretPayload + '\'', { encoding: 'utf8' });
            
            console.log('‚úÖ Webhook secret stored as GitHub repository secret');
            
            // 6. Update domain mappings with price IDs and webhook info
            console.log('\\nüìù Updating domain mappings with price IDs and webhook info...');
            
            // Read current domain mappings
            const currentMappings = JSON.parse(fs.readFileSync('/tmp/domains.json', 'utf8'));
            
            // Update mappings with price IDs and webhook info
            const updatedMappings = currentMappings.map(domainObj => {
              const result = results.find(r => r.domain === domainObj.domain);
              if (result) {
                return {
                  ...domainObj,
                  stripe_price_id: result.price_id,
                  stripe_product_id: result.product_id,
                  stripe_webhook_id: webhook.id
                };
              }
              return domainObj;
            });
            
            // Upload updated mappings to R2
            const uploadResponse = await fetch('https://api.cloudflare.com/client/v4/accounts/${{ inputs.cloudflare_account_id }}/r2/buckets/domain-mappings/objects/mappings.json', {
              method: 'PUT',
              headers: {
                'Authorization': 'Bearer ${{ inputs.cloudflare_api_token }}',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(updatedMappings)
            });
            
            if (!uploadResponse.ok) {
              console.error('‚ùå Failed to update domain mappings');
              const errorText = await uploadResponse.text();
              console.error('Upload error:', errorText);
              process.exit(1);
            }
            
            console.log('‚úÖ Successfully updated domain mappings with Stripe configuration');
            console.log('Updated mappings:');
            updatedMappings.forEach(mapping => {
              console.log('  ' + mapping.domain + ': Price ID ' + mapping.stripe_price_id + ', Webhook ' + mapping.stripe_webhook_id);
            });
            
            console.log('\\n‚úÖ Stripe setup complete for all domains!');
            
          } catch (error) {
            console.error('‚ùå Stripe setup failed:', error.message);
            process.exit(1);
          }
        }
        
        setupStripe();
        " 